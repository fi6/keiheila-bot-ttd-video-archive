"""
This type stub file was generated by pyright.
"""

import contextlib
import platform
import sys
from bson.son import SON
from pymongo import __version__
from pymongo.errors import PyMongoError

_MAX_TCP_KEEPIDLE = 120
_MAX_TCP_KEEPINTVL = 10
_MAX_TCP_KEEPCNT = 9
if sys.platform == 'win32':
    ...
else:
    ...
_METADATA = SON([('driver', SON([('name', 'PyMongo'), ('version', __version__)]))])
if sys.platform.startswith('linux'):
    ...
else:
    ...
if platform.python_implementation().startswith('PyPy'):
    ...
else:
    ...
class PoolOptions(object):
    __slots__ = ...
    def __init__(self, max_pool_size=..., min_pool_size=..., max_idle_time_seconds=..., connect_timeout=..., socket_timeout=..., wait_queue_timeout=..., wait_queue_multiple=..., ssl_context=..., ssl_match_hostname=..., socket_keepalive=..., event_listeners=..., appname=..., driver=..., compression_settings=...) -> None:
        ...
    
    @property
    def non_default_options(self):
        """The non-default options this pool was created with.

        Added for CMAP's :class:`PoolCreatedEvent`.
        """
        ...
    
    @property
    def max_pool_size(self):
        """The maximum allowable number of concurrent connections to each
        connected server. Requests to a server will block if there are
        `maxPoolSize` outstanding connections to the requested server.
        Defaults to 100. Cannot be 0.

        When a server's pool has reached `max_pool_size`, operations for that
        server block waiting for a socket to be returned to the pool. If
        ``waitQueueTimeoutMS`` is set, a blocked operation will raise
        :exc:`~pymongo.errors.ConnectionFailure` after a timeout.
        By default ``waitQueueTimeoutMS`` is not set.
        """
        ...
    
    @property
    def min_pool_size(self):
        """The minimum required number of concurrent connections that the pool
        will maintain to each connected server. Default is 0.
        """
        ...
    
    @property
    def max_idle_time_seconds(self):
        """The maximum number of seconds that a connection can remain
        idle in the pool before being removed and replaced. Defaults to
        `None` (no limit).
        """
        ...
    
    @property
    def connect_timeout(self):
        """How long a connection can take to be opened before timing out.
        """
        ...
    
    @property
    def socket_timeout(self):
        """How long a send or receive on a socket can take before timing out.
        """
        ...
    
    @property
    def wait_queue_timeout(self):
        """How long a thread will wait for a socket from the pool if the pool
        has no free sockets.
        """
        ...
    
    @property
    def wait_queue_multiple(self):
        """Multiplied by max_pool_size to give the number of threads allowed
        to wait for a socket at one time.
        """
        ...
    
    @property
    def ssl_context(self):
        """An SSLContext instance or None.
        """
        ...
    
    @property
    def ssl_match_hostname(self):
        """Call ssl.match_hostname if cert_reqs is not ssl.CERT_NONE.
        """
        ...
    
    @property
    def socket_keepalive(self):
        """Whether to send periodic messages to determine if a connection
        is closed.
        """
        ...
    
    @property
    def event_listeners(self):
        """An instance of pymongo.monitoring._EventListeners.
        """
        ...
    
    @property
    def appname(self):
        """The application name, for sending with ismaster in server handshake.
        """
        ...
    
    @property
    def driver(self):
        """Driver name and version, for sending with ismaster in handshake.
        """
        ...
    
    @property
    def compression_settings(self):
        ...
    
    @property
    def metadata(self):
        """A dict of metadata about the application, driver, os, and platform.
        """
        ...
    


class _CancellationContext(object):
    def __init__(self) -> None:
        ...
    
    def cancel(self):
        """Cancel this context."""
        ...
    
    @property
    def cancelled(self):
        """Was cancel called?"""
        ...
    


class SocketInfo(object):
    """Store a socket with some metadata.

    :Parameters:
      - `sock`: a raw socket object
      - `pool`: a Pool instance
      - `address`: the server's (host, port)
      - `id`: the id of this socket in it's pool
    """
    def __init__(self, sock, pool, address, id) -> None:
        ...
    
    def ismaster(self, all_credentials=...):
        ...
    
    def command(self, dbname, spec, slave_ok=..., read_preference=..., codec_options=..., check=..., allowable_errors=..., check_keys=..., read_concern=..., write_concern=..., parse_write_concern_error=..., collation=..., session=..., client=..., retryable_write=..., publish_events=..., user_fields=..., exhaust_allowed=...):
        """Execute a command or raise an error.

        :Parameters:
          - `dbname`: name of the database on which to run the command
          - `spec`: a command document as a dict, SON, or mapping object
          - `slave_ok`: whether to set the SlaveOkay wire protocol bit
          - `read_preference`: a read preference
          - `codec_options`: a CodecOptions instance
          - `check`: raise OperationFailure if there are errors
          - `allowable_errors`: errors to ignore if `check` is True
          - `check_keys`: if True, check `spec` for invalid keys
          - `read_concern`: The read concern for this command.
          - `write_concern`: The write concern for this command.
          - `parse_write_concern_error`: Whether to parse the
            ``writeConcernError`` field in the command response.
          - `collation`: The collation for this command.
          - `session`: optional ClientSession instance.
          - `client`: optional MongoClient for gossipping $clusterTime.
          - `retryable_write`: True if this command is a retryable write.
          - `publish_events`: Should we publish events for this command?
          - `user_fields` (optional): Response fields that should be decoded
            using the TypeDecoders from codec_options, passed to
            bson._decode_all_selective.
        """
        ...
    
    def send_message(self, message, max_doc_size):
        """Send a raw BSON message or raise ConnectionFailure.

        If a network exception is raised, the socket is closed.
        """
        ...
    
    def receive_message(self, request_id):
        """Receive a raw BSON message or raise ConnectionFailure.

        If any exception is raised, the socket is closed.
        """
        ...
    
    def legacy_write(self, request_id, msg, max_doc_size, with_last_error):
        """Send OP_INSERT, etc., optionally returning response as a dict.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `request_id`: an int.
          - `msg`: bytes, an OP_INSERT, OP_UPDATE, or OP_DELETE message,
            perhaps with a getlasterror command appended.
          - `max_doc_size`: size in bytes of the largest document in `msg`.
          - `with_last_error`: True if a getlasterror command is appended.
        """
        ...
    
    def write_command(self, request_id, msg):
        """Send "insert" etc. command, returning response as a dict.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `request_id`: an int.
          - `msg`: bytes, the command message.
        """
        ...
    
    def check_auth(self, all_credentials):
        """Update this socket's authentication.

        Log in or out to bring this socket's credentials up to date with
        those provided. Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `all_credentials`: dict, maps auth source to MongoCredential.
        """
        ...
    
    def authenticate(self, credentials):
        """Log in to the server and store these credentials in `authset`.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `credentials`: A MongoCredential.
        """
        ...
    
    def validate_session(self, client, session):
        """Validate this session before use with client.

        Raises error if this session is logged in as a different user or
        the client is not the one that created the session.
        """
        ...
    
    def close_socket(self, reason):
        """Close this connection with a reason."""
        ...
    
    def socket_closed(self):
        """Return True if we know socket has been closed, False otherwise."""
        ...
    
    def send_cluster_time(self, command, session, client):
        """Add cluster time for MongoDB >= 3.6."""
        ...
    
    def update_last_checkin_time(self):
        ...
    
    def update_is_writable(self, is_writable):
        ...
    
    def idle_time_seconds(self):
        """Seconds since this socket was last checked into its pool."""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self):
        ...
    


class _PoolClosedError(PyMongoError):
    """Internal error raised when a thread tries to get a connection from a
    closed pool.
    """
    ...


class Pool:
    def __init__(self, address, options, handshake=...) -> None:
        """
        :Parameters:
          - `address`: a (hostname, port) tuple
          - `options`: a PoolOptions instance
          - `handshake`: whether to call ismaster for each new SocketInfo
        """
        ...
    
    def update_is_writable(self, is_writable):
        """Updates the is_writable attribute on all sockets currently in the
        Pool.
        """
        ...
    
    def reset(self):
        ...
    
    def close(self):
        ...
    
    def remove_stale_sockets(self, reference_generation, all_credentials):
        """Removes stale sockets then adds new ones if pool is too small and
        has not been reset. The `reference_generation` argument specifies the
        `generation` at the point in time this operation was requested on the
        pool.
        """
        ...
    
    def connect(self, all_credentials=...):
        """Connect to Mongo and return a new SocketInfo.

        Can raise ConnectionFailure or CertificateError.

        Note that the pool does not keep a reference to the socket -- you
        must call return_socket() when you're done with it.
        """
        ...
    
    @contextlib.contextmanager
    def get_socket(self, all_credentials, checkout=...):
        """Get a socket from the pool. Use with a "with" statement.

        Returns a :class:`SocketInfo` object wrapping a connected
        :class:`socket.socket`.

        This method should always be used in a with-statement::

            with pool.get_socket(credentials, checkout) as socket_info:
                socket_info.send_message(msg)
                data = socket_info.receive_message(op_code, request_id)

        The socket is logged in or out as needed to match ``all_credentials``
        using the correct authentication mechanism for the server's wire
        protocol version.

        Can raise ConnectionFailure or OperationFailure.

        :Parameters:
          - `all_credentials`: dict, maps auth source to MongoCredential.
          - `checkout` (optional): keep socket checked out.
        """
        ...
    
    def return_socket(self, sock_info):
        """Return the socket to the pool, or if it's closed discard it.

        :Parameters:
          - `sock_info`: The socket to check into the pool.
        """
        ...
    
    def __del__(self):
        ...
    


