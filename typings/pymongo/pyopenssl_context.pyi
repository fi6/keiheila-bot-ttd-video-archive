"""
This type stub file was generated by pyright.
"""

import ssl as _stdlibssl
from OpenSSL import SSL as _SSL

"""A CPython compatible SSLContext implementation wrapping PyOpenSSL's
context.
"""
PROTOCOL_SSLv23 = _SSL.SSLv23_METHOD
OP_NO_SSLv2 = _SSL.OP_NO_SSLv2
OP_NO_SSLv3 = _SSL.OP_NO_SSLv3
OP_NO_COMPRESSION = _SSL.OP_NO_COMPRESSION
OP_NO_RENEGOTIATION = getattr(_SSL, "OP_NO_RENEGOTIATION", 0)
HAS_SNI = True
CHECK_HOSTNAME_SAFE = True
IS_PYOPENSSL = True
SSLError = _SSL.Error
_VERIFY_MAP = { _stdlibssl.CERT_NONE: _SSL.VERIFY_NONE,_stdlibssl.CERT_OPTIONAL: _SSL.VERIFY_PEER,_stdlibssl.CERT_REQUIRED: _SSL.VERIFY_PEER | _SSL.VERIFY_FAIL_IF_NO_PEER_CERT }
_REVERSE_VERIFY_MAP = dict((value, key) for (key, value) in _VERIFY_MAP.items())
_RETRY_ERRORS = (_SSL.WantReadError, _SSL.WantWriteError, _SSL.WantX509LookupError)
class _sslConn(_SSL.Connection):
    def __init__(self, ctx, sock, suppress_ragged_eofs) -> None:
        ...
    
    def do_handshake(self, *args, **kwargs):
        ...
    
    def recv(self, *args, **kwargs):
        ...
    
    def recv_into(self, *args, **kwargs):
        ...
    
    def sendall(self, buf, flags=...):
        ...
    


class _CallbackData(object):
    """Data class which is passed to the OCSP callback."""
    def __init__(self) -> None:
        ...
    


class SSLContext(object):
    """A CPython compatible SSLContext implementation wrapping PyOpenSSL's
    context.
    """
    __slots__ = ...
    def __init__(self, protocol) -> None:
        ...
    
    @property
    def protocol(self):
        """The protocol version chosen when constructing the context.
        This attribute is read-only.
        """
        ...
    
    verify_mode = ...
    check_hostname = ...
    check_ocsp_endpoint = ...
    options = ...
    def load_cert_chain(self, certfile, keyfile=..., password=...):
        """Load a private key and the corresponding certificate. The certfile
        string must be the path to a single file in PEM format containing the
        certificate as well as any number of CA certificates needed to
        establish the certificate's authenticity. The keyfile string, if
        present, must point to a file containing the private key. Otherwise
        the private key will be taken from certfile as well.
        """
        ...
    
    def load_verify_locations(self, cafile=..., capath=...):
        """Load a set of "certification authority"(CA) certificates used to
        validate other peers' certificates when `~verify_mode` is other than
        ssl.CERT_NONE.
        """
        ...
    
    def set_default_verify_paths(self):
        """Specify that the platform provided CA certificates are to be used
        for verification purposes."""
        ...
    
    def wrap_socket(self, sock, server_side=..., do_handshake_on_connect=..., suppress_ragged_eofs=..., server_hostname=..., session=...):
        """Wrap an existing Python socket sock and return a TLS socket
        object.
        """
        ...
    


