"""
This type stub file was generated by pyright.
"""

import struct
from bson import CodecOptions
from bson.son import SON

"""Tools for creating `messages
<http://www.mongodb.org/display/DOCS/Mongo+Wire+Protocol>`_ to be sent to
MongoDB.

.. note:: This module is for internal use and is generally not needed by
   application developers.
"""
MAX_INT32 = 2147483647
MIN_INT32 = - 2147483648
_COMMAND_OVERHEAD = 16382
_INSERT = 0
_UPDATE = 1
_DELETE = 2
_EMPTY = b''
_BSONOBJ = b'\x03'
_ZERO_8 = b'\x00'
_ZERO_16 = b'\x00\x00'
_ZERO_32 = b'\x00\x00\x00\x00'
_ZERO_64 = b'\x00\x00\x00\x00\x00\x00\x00\x00'
_SKIPLIM = b'\x00\x00\x00\x00\xff\xff\xff\xff'
_OP_MAP = { _INSERT: b'\x04documents\x00\x00\x00\x00\x00',_UPDATE: b'\x04updates\x00\x00\x00\x00\x00',_DELETE: b'\x04deletes\x00\x00\x00\x00\x00' }
_FIELD_MAP = { 'insert': 'documents','update': 'updates','delete': 'deletes' }
_UJOIN = u"%s.%s"
_UNICODE_REPLACE_CODEC_OPTIONS = CodecOptions(unicode_decode_error_handler='replace')
_OPTIONS = SON([('tailable', 2), ('oplogReplay', 8), ('noCursorTimeout', 16), ('awaitData', 32), ('allowPartialResults', 128)])
_MODIFIERS = SON([('$query', 'filter'), ('$orderby', 'sort'), ('$hint', 'hint'), ('$comment', 'comment'), ('$maxScan', 'maxScan'), ('$maxTimeMS', 'maxTimeMS'), ('$max', 'max'), ('$min', 'min'), ('$returnKey', 'returnKey'), ('$showRecordId', 'showRecordId'), ('$showDiskLoc', 'showRecordId'), ('$snapshot', 'snapshot')])
class _Query(object):
    """A query operation."""
    __slots__ = ...
    exhaust_mgr = ...
    cursor_id = ...
    def __init__(self, flags, db, coll, ntoskip, spec, fields, codec_options, read_preference, limit, batch_size, read_concern, collation, session, client, allow_disk_use) -> None:
        ...
    
    def namespace(self):
        ...
    
    def use_command(self, sock_info, exhaust):
        ...
    
    def as_command(self, sock_info):
        """Return a find command document for this query."""
        ...
    
    def get_message(self, set_slave_ok, sock_info, use_cmd=...):
        """Get a query message, possibly setting the slaveOk bit."""
        ...
    


class _GetMore(object):
    """A getmore operation."""
    __slots__ = ...
    name = ...
    def __init__(self, db, coll, ntoreturn, cursor_id, codec_options, read_preference, session, client, max_await_time_ms, exhaust_mgr) -> None:
        ...
    
    def namespace(self):
        ...
    
    def use_command(self, sock_info, exhaust):
        ...
    
    def as_command(self, sock_info):
        """Return a getMore command document for this query."""
        ...
    
    def get_message(self, dummy0, sock_info, use_cmd=...):
        """Get a getmore message."""
        ...
    


class _RawBatchQuery(_Query):
    def use_command(self, socket_info, exhaust):
        ...
    
    def get_message(self, set_slave_ok, sock_info, use_cmd=...):
        ...
    


class _RawBatchGetMore(_GetMore):
    def use_command(self, socket_info, exhaust):
        ...
    
    def get_message(self, set_slave_ok, sock_info, use_cmd=...):
        ...
    


class _CursorAddress(tuple):
    """The server address (host, port) of a cursor, with namespace property."""
    def __new__(cls, address, namespace):
        ...
    
    @property
    def namespace(self):
        """The namespace this cursor."""
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


_pack_compression_header = struct.Struct("<iiiiiiB").pack
_COMPRESSION_HEADER_SIZE = 25
_pack_header = struct.Struct("<iiii").pack
_pack_int = struct.Struct("<i").pack
if _use_c:
    _insert_uncompressed = _cmessage._insert_message
def insert(collection_name, docs, check_keys, safe, last_error_args, continue_on_error, opts, ctx=...):
    """Get an **insert** message."""
    ...

if _use_c:
    _update_uncompressed = _cmessage._update_message
def update(collection_name, upsert, multi, spec, doc, safe, last_error_args, check_keys, opts, ctx=...):
    """Get an **update** message."""
    ...

_pack_op_msg_flags_type = struct.Struct("<IB").pack
_pack_byte = struct.Struct("<B").pack
if _use_c:
    _op_msg_uncompressed = _cmessage._op_msg
if _use_c:
    _query_uncompressed = _cmessage._query_message
def query(options, collection_name, num_to_skip, num_to_return, query, field_selector, opts, check_keys=..., ctx=...):
    """Get a **query** message."""
    ...

_pack_long_long = struct.Struct("<q").pack
if _use_c:
    _get_more_uncompressed = _cmessage._get_more_message
def get_more(collection_name, num_to_return, cursor_id, ctx=...):
    """Get a **getMore** message."""
    ...

def delete(collection_name, spec, safe, last_error_args, opts, flags=..., ctx=...):
    """Get a **delete** message.

    `opts` is a CodecOptions. `flags` is a bit vector that may contain
    the SingleRemove flag or not:

    http://docs.mongodb.org/meta-driver/latest/legacy/mongodb-wire-protocol/#op-delete
    """
    ...

def kill_cursors(cursor_ids):
    """Get a **killCursors** message.
    """
    ...

class _BulkWriteContext(object):
    """A wrapper around SocketInfo for use with write splitting functions."""
    __slots__ = ...
    def __init__(self, database_name, command, sock_info, operation_id, listeners, session, op_type, codec) -> None:
        ...
    
    def execute(self, docs, client):
        ...
    
    def execute_unack(self, docs, client):
        ...
    
    @property
    def check_keys(self):
        """Should we check keys for this operation type?"""
        ...
    
    @property
    def max_bson_size(self):
        """A proxy for SockInfo.max_bson_size."""
        ...
    
    @property
    def max_message_size(self):
        """A proxy for SockInfo.max_message_size."""
        ...
    
    @property
    def max_write_batch_size(self):
        """A proxy for SockInfo.max_write_batch_size."""
        ...
    
    @property
    def max_split_size(self):
        """The maximum size of a BSON command before batch splitting."""
        ...
    
    def legacy_bulk_insert(self, request_id, msg, max_doc_size, acknowledged, docs, compress):
        ...
    
    def legacy_write(self, request_id, msg, max_doc_size, acknowledged, docs):
        """A proxy for SocketInfo.legacy_write that handles event publishing.
        """
        ...
    
    def write_command(self, request_id, msg, docs):
        """A proxy for SocketInfo.write_command that handles event publishing.
        """
        ...
    


_MAX_SPLIT_SIZE_ENC = 2097152
class _EncryptedBulkWriteContext(_BulkWriteContext):
    __slots__ = ...
    def execute(self, docs, client):
        ...
    
    def execute_unack(self, docs, client):
        ...
    
    @property
    def max_split_size(self):
        """Reduce the batch splitting size."""
        ...
    


if _use_c:
    _do_batched_insert = _cmessage._do_batched_insert
_OP_MSG_MAP = { _INSERT: b'documents\x00',_UPDATE: b'updates\x00',_DELETE: b'deletes\x00' }
if _use_c:
    _encode_batched_op_msg = _cmessage._encode_batched_op_msg
if _use_c:
    _batched_op_msg = _cmessage._batched_op_msg
if _use_c:
    _encode_batched_write_command = _cmessage._encode_batched_write_command
if _use_c:
    _batched_write_command = _cmessage._batched_write_command
class _OpReply(object):
    """A MongoDB OP_REPLY response message."""
    __slots__ = ...
    UNPACK_FROM = ...
    OP_CODE = ...
    def __init__(self, flags, cursor_id, number_returned, documents) -> None:
        ...
    
    def raw_response(self, cursor_id=...):
        """Check the response header from the database, without decoding BSON.

        Check the response for errors and unpack.

        Can raise CursorNotFound, NotMasterError, ExecutionTimeout, or
        OperationFailure.

        :Parameters:
          - `cursor_id` (optional): cursor_id we sent to get this response -
            used for raising an informative exception when we get cursor id not
            valid at server response.
        """
        ...
    
    def unpack_response(self, cursor_id=..., codec_options=..., user_fields=..., legacy_response=...):
        """Unpack a response from the database and decode the BSON document(s).

        Check the response for errors and unpack, returning a dictionary
        containing the response data.

        Can raise CursorNotFound, NotMasterError, ExecutionTimeout, or
        OperationFailure.

        :Parameters:
          - `cursor_id` (optional): cursor_id we sent to get this response -
            used for raising an informative exception when we get cursor id not
            valid at server response
          - `codec_options` (optional): an instance of
            :class:`~bson.codec_options.CodecOptions`
        """
        ...
    
    def command_response(self):
        """Unpack a command response."""
        ...
    
    def raw_command_response(self):
        """Return the bytes of the command response."""
        ...
    
    @property
    def more_to_come(self):
        """Is the moreToCome bit set on this response?"""
        ...
    
    @classmethod
    def unpack(cls, msg):
        """Construct an _OpReply from raw bytes."""
        ...
    


class _OpMsg(object):
    """A MongoDB OP_MSG response message."""
    __slots__ = ...
    UNPACK_FROM = ...
    OP_CODE = ...
    CHECKSUM_PRESENT = ...
    MORE_TO_COME = ...
    EXHAUST_ALLOWED = ...
    def __init__(self, flags, payload_document) -> None:
        ...
    
    def raw_response(self, cursor_id=...):
        ...
    
    def unpack_response(self, cursor_id=..., codec_options=..., user_fields=..., legacy_response=...):
        """Unpack a OP_MSG command response.

        :Parameters:
          - `cursor_id` (optional): Ignored, for compatibility with _OpReply.
          - `codec_options` (optional): an instance of
            :class:`~bson.codec_options.CodecOptions`
        """
        ...
    
    def command_response(self):
        """Unpack a command response."""
        ...
    
    def raw_command_response(self):
        """Return the bytes of the command response."""
        ...
    
    @property
    def more_to_come(self):
        """Is the moreToCome bit set on this response?"""
        ...
    
    @classmethod
    def unpack(cls, msg):
        """Construct an _OpMsg from raw bytes."""
        ...
    


_UNPACK_REPLY = { _OpReply.OP_CODE: _OpReply.unpack,_OpMsg.OP_CODE: _OpMsg.unpack }
